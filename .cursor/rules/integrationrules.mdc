---
alwaysApply: true

Comprehensive Integration Rules for MERN Stack Mentoring Platform
ğŸ—ï¸ SYSTEM ARCHITECTURE OVERVIEW
javascript
// architecture/integration-rules.js
/**
 * MENTORING PLATFORM INTEGRATION RULES
 * Version: 1.0
 * Last Updated: 2024
 */

const IntegrationRules = {
  // Core Principles
  principles: {
    singleSourceOfTruth: "All data flows from backend APIs to frontend state",
    unidirectionalDataFlow: "Data flows down, events flow up",
    optimisticUpdates: "UI updates immediately, rolls back on failure",
    errorBoundaries: "Components handle their own error states",
    typeSafety: "TypeScript/PropTypes for all data contracts"
  },

  // Data Flow Architecture
  dataFlow: {
    clientState: "Zustand for UI state (forms, modals, filters)",
    serverState: "React Query for API data (users, sessions, analytics)",
    realTime: "WebSocket for live notifications and updates",
    persistence: "Redis for session cache, MongoDB for persistent data"
  }
};
ğŸ”„ DATA FLOW INTEGRATION RULES
1. API CLIENT STANDARDS
javascript
// services/api-integration-rules.js
export const APIIntegrationRules = {
  // Request Standards
  request: {
    timeout: 10000, // 10 seconds
    retryAttempts: 2,
    headers: {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    }
  },

  // Response Standards
  response: {
    successFormat: {
      success: 'boolean',
      data: 'object|array',
      message: 'string',
      code: 'string',
      timestamp: 'ISO8601'
    },
    errorFormat: {
      success: 'false',
      message: 'string',
      code: 'string',
      errors: 'array[object]',
      timestamp: 'ISO8601'
    }
  },

  // Error Handling
  errorCodes: {
    VALIDATION_ERROR: '400',
    UNAUTHORIZED: '401',
    FORBIDDEN: '403',
    NOT_FOUND: '404',
    RATE_LIMIT_EXCEEDED: '429',
    SERVER_ERROR: '500'
  }
};
2. REACT QUERY INTEGRATION RULES
javascript
// hooks/query-integration-rules.js
import { useQuery, useMutation, useQueryClient } from 'react-query';

export const QueryIntegrationRules = {
  // Query Configuration
  queryDefaults: {
    staleTime: 5 * 60 * 1000,     // 5 minutes
    cacheTime: 10 * 60 * 1000,    // 10 minutes
    retry: (failureCount, error) => {
      // Don't retry on 4xx errors
      if (error?.status >= 400 && error?.status < 500) return false;
      return failureCount < 2;
    },
    refetchOnWindowFocus: false,
    refetchOnReconnect: true
  },

  // Mutation Configuration
  mutationDefaults: {
    retry: 1,
    onError: (error, variables, context) => {
      // Global error handling for mutations
      console.error('Mutation failed:', error);
    }
  },

  // Query Key Structure
  queryKeys: {
    // Admin
    adminDashboard: ['admin', 'dashboard'],
    userManagement: (filters) => ['admin', 'users', filters],
    analytics: (dateRange) => ['admin', 'analytics', dateRange],

    // Mentor
    mentorDashboard: ['mentor', 'dashboard'],
    mentorSessions: (mentorId, status) => ['mentor', 'sessions', mentorId, status],
    menteeProgress: (mentorId) => ['mentor', 'mentees', mentorId],

    // Mentee
    menteeDashboard: ['mentee', 'dashboard'],
    menteeGoals: (menteeId) => ['mentee', 'goals', menteeId],
    learningResources: (menteeId) => ['mentee', 'resources', menteeId]
  }
};

// Example Query Hook with Integration Rules
export const useAdminDashboard = () => {
  return useQuery(
    QueryIntegrationRules.queryKeys.adminDashboard,
    () => adminApi.getDashboardData(),
    {
      ...QueryIntegrationRules.queryDefaults,
      refetchInterval: 30000, // 30 seconds for admin dashboard
      onError: (error) => {
        // Specific error handling for admin dashboard
        if (error.code === 'UNAUTHORIZED') {
          window.location.href = '/login';
        }
      }
    }
  );
};
3. STATE MANAGEMENT INTEGRATION RULES
javascript
// stores/state-integration-rules.js
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

export const StateIntegrationRules = {
  // Store Structure
  storePatterns: {
    // UI State Pattern
    uiStore: {
      modals: 'object',
      notifications: 'array',
      loadingStates: 'object',
      theme: 'string'
    },

    // Form State Pattern
    formStore: {
      currentForm: 'string',
      formData: 'object',
      validationErrors: 'object',
      submitStatus: 'idle|loading|success|error'
    },

    // User Session Pattern
    sessionStore: {
      user: 'object|null',
      permissions: 'array',
      preferences: 'object'
    }
  },

  // State Update Rules
  updateRules: {
    immutableUpdates: "Always return new state objects",
    actionNames: "Use descriptive action names (verbs)",
    sideEffects: "Handle side effects in actions, not components",
    serializable: "Keep state serializable for debugging"
  }
};

// Example UI Store with Integration Rules
export const useUIStore = create(
  devtools(
    (set, get) => ({
      // State
      modals: {},
      notifications: [],
      loadingStates: {},

      // Actions
      openModal: (modalName, modalData = {}) => 
        set(state => ({
          modals: {
            ...state.modals,
            [modalName]: { open: true, data: modalData }
          }
        })),

      closeModal: (modalName) =>
        set(state => ({
          modals: {
            ...state.modals,
            [modalName]: { open: false, data: null }
          }
        })),

      addNotification: (notification) =>
        set(state => ({
          notifications: [
            ...state.notifications,
            {
              id: Date.now(),
              timestamp: new Date().toISOString(),
              ...notification
            }
          ]
        })),

      removeNotification: (notificationId) =>
        set(state => ({
          notifications: state.notifications.filter(n => n.id !== notificationId)
        })),

      setLoading: (key, isLoading) =>
        set(state => ({
          loadingStates: {
            ...state.loadingStates,
            [key]: isLoading
          }
        }))
    }),
    { name: 'UI Store' }
  )
);
ğŸ” AUTHENTICATION & AUTHORIZATION INTEGRATION
javascript
// auth/auth-integration-rules.js
export const AuthIntegrationRules = {
  // Token Management
  token: {
    storage: 'localStorage',
    key: 'mentoringPlatformAuth',
    refreshThreshold: 5 * 60 * 1000, // 5 minutes before expiry
    autoRefresh: true
  },

  // Role-Based Access Control
  roles: {
    admin: ['*'],
    mentor: [
      'sessions:read',
      'sessions:write', 
      'mentees:read',
      'messages:read',
      'messages:write'
    ],
    mentee: [
      'sessions:read', 
      'goals:read',
      'goals:write',
      'resources:read'
    ]
  },

  // Route Protection
  routes: {
    '/admin/*': ['admin'],
    '/mentor/*': ['mentor', 'admin'],
    '/mentee/*': ['mentee', 'mentor', 'admin']
  }
};

// Authentication Hook with Integration Rules
export const useAuth = () => {
  const queryClient = useQueryClient();

  const login = useMutation(
    (credentials) => authApi.login(credentials),
    {
      onSuccess: (data) => {
        // Store token
        localStorage.setItem(AuthIntegrationRules.token.key, data.token);
        
        // Invalidate all queries to refetch with new permissions
        queryClient.invalidateQueries();
        
        // Redirect based on role
        const userRole = data.user.role;
        const redirectPath = getRedirectPath(userRole);
        window.location.href = redirectPath;
      },
      onError: (error) => {
        // Handle specific auth errors
        if (error.code === 'INVALID_CREDENTIALS') {
          throw new Error('Invalid email or password');
        }
        if (error.code === 'ACCOUNT_LOCKED') {
          throw new Error('Account temporarily locked. Try again later.');
        }
      }
    }
  );

  const logout = useMutation(
    () => authApi.logout(),
    {
      onSuccess: () => {
        // Clear token
        localStorage.removeItem(AuthIntegrationRules.token.key);
        
        // Clear all cached data
        queryClient.clear();
        
        // Redirect to login
        window.location.href = '/login';
      }
    }
  );

  return { login, logout };
};
ğŸ“¡ REAL-TIME INTEGRATION RULES
javascript
// realtime/websocket-integration-rules.js
export const WebSocketIntegrationRules = {
  // Connection Management
  connection: {
    url: process.env.REACT_APP_WS_URL,
    timeout: 5000,
    reconnectAttempts: 3,
    reconnectDelay: 1000
  },

  // Event Types
  events: {
    // Session Events
    SESSION_CREATED: 'session:created',
    SESSION_UPDATED: 'session:updated',
    SESSION_CANCELLED: 'session:cancelled',

    // Message Events
    MESSAGE_SENT: 'message:sent',
    MESSAGE_RECEIVED: 'message:received',

    // Notification Events
    NOTIFICATION_CREATED: 'notification:created',
    
    // System Events
    USER_ONLINE: 'user:online',
    USER_OFFLINE: 'user:offline'
  },

  // Data Validation
  validation: {
    requiredFields: ['type', 'timestamp', 'data'],
    maxPayloadSize: 1024 * 1024, // 1MB
    rateLimit: 100 // messages per minute
  }
};

// WebSocket Hook with Integration Rules
export const useWebSocket = (userId) => {
  const queryClient = useQueryClient();
  const [socket, setSocket] = useState(null);

  useEffect(() => {
    const ws = new WebSocket(
      `${WebSocketIntegrationRules.connection.url}?userId=${userId}`
    );

    ws.onopen = () => {
      console.log('WebSocket connected');
      setSocket(ws);
    };

    ws.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        
        // Validate message structure
        if (!validateMessage(message)) {
          console.warn('Invalid WebSocket message:', message);
          return;
        }

        // Handle different event types
        handleWebSocketEvent(message, queryClient);
      } catch (error) {
        console.error('WebSocket message parsing error:', error);
      }
    };

    ws.onclose = () => {
      console.log('WebSocket disconnected');
      setSocket(null);
      
      // Attempt reconnection
      setTimeout(() => {
        if (userId) {
          setSocket(new WebSocket(
            `${WebSocketIntegrationRules.connection.url}?userId=${userId}`
          ));
        }
      }, WebSocketIntegrationRules.connection.reconnectDelay);
    };

    return () => {
      ws.close();
    };
  }, [userId, queryClient]);

  const handleWebSocketEvent = (message, queryClient) => {
    const { type, data } = message;

    switch (type) {
      case WebSocketIntegrationRules.events.SESSION_UPDATED:
        // Invalidate session queries
        queryClient.invalidateQueries(['sessions']);
        break;

      case WebSocketIntegrationRules.events.MESSAGE_RECEIVED:
        // Invalidate message queries and update UI store
        queryClient.invalidateQueries(['messages']);
        useUIStore.getState().addNotification({
          type: 'info',
          title: 'New Message',
          message: `You have a new message from ${data.senderName}`
        });
        break;

      case WebSocketIntegrationRules.events.NOTIFICATION_CREATED:
        // Add notification to UI store
        useUIStore.getState().addNotification(data);
        break;

      default:
        console.log('Unhandled WebSocket event:', type);
    }
  };

  return socket;
};
ğŸ¯ COMPONENT INTEGRATION RULES
javascript
// components/component-integration-rules.js
export const ComponentIntegrationRules = {
  // Prop Types Standards
  propTypes: {
    required: 'All required props must be validated',
    defaults: 'Provide sensible default values',
    types: 'Use TypeScript or PropTypes for all props'
  },

  // Error Boundary Rules
  errorBoundaries: {
    componentLevel: "Each major feature has its own error boundary",
    fallbackUI: "Provide meaningful fallback UI for errors",
    errorLogging: "Log errors to monitoring service"
  },

  // Performance Rules
  performance: {
    memoization: "Use React.memo for expensive components",
    callbackMemo: "Use useCallback for event handlers",
    valueMemo: "Use useMemo for expensive calculations",
    codeSplitting: "Use React.lazy for route-level components"
  }
};

// Higher-Order Component with Integration Rules
export const withErrorBoundary = (WrappedComponent, fallbackComponent) => {
  return class ErrorBoundary extends React.Component {
    state = { hasError: false, error: null };

    static getDerivedStateFromError(error) {
      return { hasError: true, error };
    }

    componentDidCatch(error, errorInfo) {
      // Log error to monitoring service
      console.error('Component Error:', error, errorInfo);
      
      // Send to error tracking service
      if (window.analytics) {
        window.analytics.track('component_error', {
          error: error.message,
          component: WrappedComponent.name,
          stack: errorInfo.componentStack
        });
      }
    }

    render() {
      if (this.state.hasError) {
        if (fallbackComponent) {
          return React.createElement(fallbackComponent, {
            error: this.state.error,
            onRetry: () => this.setState({ hasError: false, error: null })
          });
        }
        
        return (
          <div className="tw-p-4 tw-bg-red-50 tw-border tw-border-red-200 tw-rounded-lg">
            <h3 className="tw-text-lg tw-font-medium tw-text-red-800">
              Something went wrong
            </h3>
            <p className="tw-text-red-600 tw-mt-2">
              {this.state.error?.message}
            </p>
            <button
              onClick={() => this.setState({ hasError: false, error: null })}
              className="tw-mt-3 tw-bg-red-100 hover:tw-bg-red-200 tw-text-red-700 tw-px-4 tw-py-2 tw-rounded"
            >
              Try Again
            </button>
          </div>
        );
      }

      return <WrappedComponent {...this.props} />;
    }
  };
};
ğŸ“Š ANALYTICS & MONITORING INTEGRATION
javascript
// analytics/analytics-integration-rules.js
export const AnalyticsIntegrationRules = {
  // Event Tracking
  events: {
    pageViews: {
      route: 'string',
      timestamp: 'ISO8601',
      userId: 'string',
      sessionId: 'string'
    },
    userActions: {
      action: 'string',
      element: 'string',
      context: 'object',
      timestamp: 'ISO8601'
    },
    errors: {
      error: 'string',
      stack: 'string',
      context: 'object',
      timestamp: 'ISO8601'
    }
  },

  // Performance Monitoring
  performance: {
    apiResponseTimes: 'track all API call durations',
    componentRenderTimes: 'track slow component renders',
    pageLoadTimes: 'track route navigation performance'
  }
};

// Analytics Hook with Integration Rules
export const useAnalytics = () => {
  const trackEvent = useCallback((eventName, properties = {}) => {
    // Don't track in development
    if (process.env.NODE_ENV === 'development') return;

    const event = {
      name: eventName,
      properties: {
        ...properties,
        timestamp: new Date().toISOString(),
        userId: getCurrentUserId(),
        sessionId: getSessionId(),
        userAgent: navigator.userAgent,
        url: window.location.href
      }
    };

    // Send to analytics service
    if (window.analytics) {
      window.analytics.track(eventName, event.properties);
    }

    // Also log to console in development
    console.log(`[Analytics] ${eventName}:`, event.properties);
  }, []);

  const trackPageView = useCallback((route, additionalProps = {}) => {
    trackEvent('page_view', {
      route,
      ...additionalProps
    });
  }, [trackEvent]);

  const trackUserAction = useCallback((action, element, context = {}) => {
    trackEvent('user_action', {
      action,
      element,
      context
    });
  }, [trackEvent]);

  return {
    trackEvent,
    trackPageView,
    trackUserAction
  };
};
ğŸ”§ DEPLOYMENT & ENVIRONMENT INTEGRATION
javascript
// config/environment-integration-rules.js
export const EnvironmentIntegrationRules = {
  // Environment Variables
  env: {
    required: [
      'REACT_APP_API_URL',
      'REACT_APP_WS_URL',
      'REACT_APP_ANALYTICS_ID'
    ],
    optional: [
      'REACT_APP_SENTRY_DSN',
      'REACT_APP_LOGGING_LEVEL'
    ]
  },

  // Feature Flags
  featureFlags: {
    release: {
      newMatchingAlgorithm: true,
      videoSessions: false,
      advancedAnalytics: true
    },
    development: {
      newMatchingAlgorithm: true,
      videoSessions: true,
      advancedAnalytics: true
    }
  },

  // API Endpoints
  endpoints: {
    development: {
      api: 'http://localhost:5000/api',
      ws: 'ws://localhost:5000'
    },
    staging: {
      api: 'https://staging-api.mentorplatform.com/api',
      ws: 'wss://staging-api.mentorplatform.com'
    },
    production: {
      api: 'https://api.mentorplatform.com/api',
      ws: 'wss://api.mentorplatform.com'
    }
  }
};

// Configuration Hook with Integration Rules
export const useConfig = () => {
  const validateEnvironment = () => {
    const missingVars = EnvironmentIntegrationRules.env.required.filter(
      varName => !process.env[varName]
    );

    if (missingVars.length > 0) {
      throw new Error(
        `Missing required environment variables: ${missingVars.join(', ')}`
      );
    }
  };

  const getApiUrl = () => {
    const env = process.env.NODE_ENV;
    return EnvironmentIntegrationRules.endpoints[env]?.api || 
           EnvironmentIntegrationRules.endpoints.production.api;
  };

  const getWebSocketUrl = () => {
    const env = process.env.NODE_ENV;
    return EnvironmentIntegrationRules.endpoints[env]?.ws || 
           EnvironmentIntegrationRules.endpoints.production.ws;
  };

  const isFeatureEnabled = (featureName) => {
    const env = process.env.NODE_ENV;
    return EnvironmentIntegrationRules.featureFlags[env]?.[featureName] ?? false;
  };

  return {
    validateEnvironment,
    getApiUrl,
    getWebSocketUrl,
    isFeatureEnabled
  };
};
ğŸ“ INTEGRATION CHECKLIST
javascript
// utils/integration-checklist.js
export const IntegrationChecklist = {
  beforePR: [
    "âœ… All API calls use React Query hooks",
    "âœ… Error boundaries wrap major components",
    "âœ… PropTypes/TypeScript definitions updated",
    "âœ… Tailwind classes use tw- prefix only",
    "âœ… No inline styles or custom CSS",
    "âœ… Loading states implemented for all async operations",
    "âœ… Error states handled gracefully",
    "âœ… Real-time updates tested",
    "âœ… Performance optimizations applied",
    "âœ… Accessibility attributes included"
  ],

  beforeDeploy: [
    "âœ… Environment variables validated",
    "âœ… Feature flags configured",
    "âœ… Analytics events tracked",
    "âœ… Error logging integrated",
    "âœ… API endpoints verified",
    "âœ… WebSocket connections stable",
    "âœ… Mobile responsiveness tested",
    "âœ… Cross-browser compatibility checked"
  ]
};
This comprehensive integration rule system ensures consistency, maintainability, and scalability across your MERN stack Mentoring Platform while strictly following the tw- prefix requirements for Tailwind CSS.
---
Comprehensive Integration Rules for MERN Stack Mentoring Platform
ğŸ—ï¸ SYSTEM ARCHITECTURE OVERVIEW
javascript
// architecture/integration-rules.js
/**
 * MENTORING PLATFORM INTEGRATION RULES
 * Version: 1.0
 * Last Updated: 2024
 */

const IntegrationRules = {
  // Core Principles
  principles: {
    singleSourceOfTruth: "All data flows from backend APIs to frontend state",
    unidirectionalDataFlow: "Data flows down, events flow up",
    optimisticUpdates: "UI updates immediately, rolls back on failure",
    errorBoundaries: "Components handle their own error states",
    typeSafety: "TypeScript/PropTypes for all data contracts"
  },

  // Data Flow Architecture
  dataFlow: {
    clientState: "Zustand for UI state (forms, modals, filters)",
    serverState: "React Query for API data (users, sessions, analytics)",
    realTime: "WebSocket for live notifications and updates",
    persistence: "Redis for session cache, MongoDB for persistent data"
  }
};
ğŸ”„ DATA FLOW INTEGRATION RULES
1. API CLIENT STANDARDS
javascript
// services/api-integration-rules.js
export const APIIntegrationRules = {
  // Request Standards
  request: {
    timeout: 10000, // 10 seconds
    retryAttempts: 2,
    headers: {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    }
  },

  // Response Standards
  response: {
    successFormat: {
      success: 'boolean',
      data: 'object|array',
      message: 'string',
      code: 'string',
      timestamp: 'ISO8601'
    },
    errorFormat: {
      success: 'false',
      message: 'string',
      code: 'string',
      errors: 'array[object]',
      timestamp: 'ISO8601'
    }
  },

  // Error Handling
  errorCodes: {
    VALIDATION_ERROR: '400',
    UNAUTHORIZED: '401',
    FORBIDDEN: '403',
    NOT_FOUND: '404',
    RATE_LIMIT_EXCEEDED: '429',
    SERVER_ERROR: '500'
  }
};
2. REACT QUERY INTEGRATION RULES
javascript
// hooks/query-integration-rules.js
import { useQuery, useMutation, useQueryClient } from 'react-query';

export const QueryIntegrationRules = {
  // Query Configuration
  queryDefaults: {
    staleTime: 5 * 60 * 1000,     // 5 minutes
    cacheTime: 10 * 60 * 1000,    // 10 minutes
    retry: (failureCount, error) => {
      // Don't retry on 4xx errors
      if (error?.status >= 400 && error?.status < 500) return false;
      return failureCount < 2;
    },
    refetchOnWindowFocus: false,
    refetchOnReconnect: true
  },

  // Mutation Configuration
  mutationDefaults: {
    retry: 1,
    onError: (error, variables, context) => {
      // Global error handling for mutations
      console.error('Mutation failed:', error);
    }
  },

  // Query Key Structure
  queryKeys: {
    // Admin
    adminDashboard: ['admin', 'dashboard'],
    userManagement: (filters) => ['admin', 'users', filters],
    analytics: (dateRange) => ['admin', 'analytics', dateRange],

    // Mentor
    mentorDashboard: ['mentor', 'dashboard'],
    mentorSessions: (mentorId, status) => ['mentor', 'sessions', mentorId, status],
    menteeProgress: (mentorId) => ['mentor', 'mentees', mentorId],

    // Mentee
    menteeDashboard: ['mentee', 'dashboard'],
    menteeGoals: (menteeId) => ['mentee', 'goals', menteeId],
    learningResources: (menteeId) => ['mentee', 'resources', menteeId]
  }
};

// Example Query Hook with Integration Rules
export const useAdminDashboard = () => {
  return useQuery(
    QueryIntegrationRules.queryKeys.adminDashboard,
    () => adminApi.getDashboardData(),
    {
      ...QueryIntegrationRules.queryDefaults,
      refetchInterval: 30000, // 30 seconds for admin dashboard
      onError: (error) => {
        // Specific error handling for admin dashboard
        if (error.code === 'UNAUTHORIZED') {
          window.location.href = '/login';
        }
      }
    }
  );
};
3. STATE MANAGEMENT INTEGRATION RULES
javascript
// stores/state-integration-rules.js
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

export const StateIntegrationRules = {
  // Store Structure
  storePatterns: {
    // UI State Pattern
    uiStore: {
      modals: 'object',
      notifications: 'array',
      loadingStates: 'object',
      theme: 'string'
    },

    // Form State Pattern
    formStore: {
      currentForm: 'string',
      formData: 'object',
      validationErrors: 'object',
      submitStatus: 'idle|loading|success|error'
    },

    // User Session Pattern
    sessionStore: {
      user: 'object|null',
      permissions: 'array',
      preferences: 'object'
    }
  },

  // State Update Rules
  updateRules: {
    immutableUpdates: "Always return new state objects",
    actionNames: "Use descriptive action names (verbs)",
    sideEffects: "Handle side effects in actions, not components",
    serializable: "Keep state serializable for debugging"
  }
};

// Example UI Store with Integration Rules
export const useUIStore = create(
  devtools(
    (set, get) => ({
      // State
      modals: {},
      notifications: [],
      loadingStates: {},

      // Actions
      openModal: (modalName, modalData = {}) => 
        set(state => ({
          modals: {
            ...state.modals,
            [modalName]: { open: true, data: modalData }
          }
        })),

      closeModal: (modalName) =>
        set(state => ({
          modals: {
            ...state.modals,
            [modalName]: { open: false, data: null }
          }
        })),

      addNotification: (notification) =>
        set(state => ({
          notifications: [
            ...state.notifications,
            {
              id: Date.now(),
              timestamp: new Date().toISOString(),
              ...notification
            }
          ]
        })),

      removeNotification: (notificationId) =>
        set(state => ({
          notifications: state.notifications.filter(n => n.id !== notificationId)
        })),

      setLoading: (key, isLoading) =>
        set(state => ({
          loadingStates: {
            ...state.loadingStates,
            [key]: isLoading
          }
        }))
    }),
    { name: 'UI Store' }
  )
);
ğŸ” AUTHENTICATION & AUTHORIZATION INTEGRATION
javascript
// auth/auth-integration-rules.js
export const AuthIntegrationRules = {
  // Token Management
  token: {
    storage: 'localStorage',
    key: 'mentoringPlatformAuth',
    refreshThreshold: 5 * 60 * 1000, // 5 minutes before expiry
    autoRefresh: true
  },

  // Role-Based Access Control
  roles: {
    admin: ['*'],
    mentor: [
      'sessions:read',
      'sessions:write', 
      'mentees:read',
      'messages:read',
      'messages:write'
    ],
    mentee: [
      'sessions:read', 
      'goals:read',
      'goals:write',
      'resources:read'
    ]
  },

  // Route Protection
  routes: {
    '/admin/*': ['admin'],
    '/mentor/*': ['mentor', 'admin'],
    '/mentee/*': ['mentee', 'mentor', 'admin']
  }
};

// Authentication Hook with Integration Rules
export const useAuth = () => {
  const queryClient = useQueryClient();

  const login = useMutation(
    (credentials) => authApi.login(credentials),
    {
      onSuccess: (data) => {
        // Store token
        localStorage.setItem(AuthIntegrationRules.token.key, data.token);
        
        // Invalidate all queries to refetch with new permissions
        queryClient.invalidateQueries();
        
        // Redirect based on role
        const userRole = data.user.role;
        const redirectPath = getRedirectPath(userRole);
        window.location.href = redirectPath;
      },
      onError: (error) => {
        // Handle specific auth errors
        if (error.code === 'INVALID_CREDENTIALS') {
          throw new Error('Invalid email or password');
        }
        if (error.code === 'ACCOUNT_LOCKED') {
          throw new Error('Account temporarily locked. Try again later.');
        }
      }
    }
  );

  const logout = useMutation(
    () => authApi.logout(),
    {
      onSuccess: () => {
        // Clear token
        localStorage.removeItem(AuthIntegrationRules.token.key);
        
        // Clear all cached data
        queryClient.clear();
        
        // Redirect to login
        window.location.href = '/login';
      }
    }
  );

  return { login, logout };
};
ğŸ“¡ REAL-TIME INTEGRATION RULES
javascript
// realtime/websocket-integration-rules.js
export const WebSocketIntegrationRules = {
  // Connection Management
  connection: {
    url: process.env.REACT_APP_WS_URL,
    timeout: 5000,
    reconnectAttempts: 3,
    reconnectDelay: 1000
  },

  // Event Types
  events: {
    // Session Events
    SESSION_CREATED: 'session:created',
    SESSION_UPDATED: 'session:updated',
    SESSION_CANCELLED: 'session:cancelled',

    // Message Events
    MESSAGE_SENT: 'message:sent',
    MESSAGE_RECEIVED: 'message:received',

    // Notification Events
    NOTIFICATION_CREATED: 'notification:created',
    
    // System Events
    USER_ONLINE: 'user:online',
    USER_OFFLINE: 'user:offline'
  },

  // Data Validation
  validation: {
    requiredFields: ['type', 'timestamp', 'data'],
    maxPayloadSize: 1024 * 1024, // 1MB
    rateLimit: 100 // messages per minute
  }
};

// WebSocket Hook with Integration Rules
export const useWebSocket = (userId) => {
  const queryClient = useQueryClient();
  const [socket, setSocket] = useState(null);

  useEffect(() => {
    const ws = new WebSocket(
      `${WebSocketIntegrationRules.connection.url}?userId=${userId}`
    );

    ws.onopen = () => {
      console.log('WebSocket connected');
      setSocket(ws);
    };

    ws.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        
        // Validate message structure
        if (!validateMessage(message)) {
          console.warn('Invalid WebSocket message:', message);
          return;
        }

        // Handle different event types
        handleWebSocketEvent(message, queryClient);
      } catch (error) {
        console.error('WebSocket message parsing error:', error);
      }
    };

    ws.onclose = () => {
      console.log('WebSocket disconnected');
      setSocket(null);
      
      // Attempt reconnection
      setTimeout(() => {
        if (userId) {
          setSocket(new WebSocket(
            `${WebSocketIntegrationRules.connection.url}?userId=${userId}`
          ));
        }
      }, WebSocketIntegrationRules.connection.reconnectDelay);
    };

    return () => {
      ws.close();
    };
  }, [userId, queryClient]);

  const handleWebSocketEvent = (message, queryClient) => {
    const { type, data } = message;

    switch (type) {
      case WebSocketIntegrationRules.events.SESSION_UPDATED:
        // Invalidate session queries
        queryClient.invalidateQueries(['sessions']);
        break;

      case WebSocketIntegrationRules.events.MESSAGE_RECEIVED:
        // Invalidate message queries and update UI store
        queryClient.invalidateQueries(['messages']);
        useUIStore.getState().addNotification({
          type: 'info',
          title: 'New Message',
          message: `You have a new message from ${data.senderName}`
        });
        break;

      case WebSocketIntegrationRules.events.NOTIFICATION_CREATED:
        // Add notification to UI store
        useUIStore.getState().addNotification(data);
        break;

      default:
        console.log('Unhandled WebSocket event:', type);
    }
  };

  return socket;
};
ğŸ¯ COMPONENT INTEGRATION RULES
javascript
// components/component-integration-rules.js
export const ComponentIntegrationRules = {
  // Prop Types Standards
  propTypes: {
    required: 'All required props must be validated',
    defaults: 'Provide sensible default values',
    types: 'Use TypeScript or PropTypes for all props'
  },

  // Error Boundary Rules
  errorBoundaries: {
    componentLevel: "Each major feature has its own error boundary",
    fallbackUI: "Provide meaningful fallback UI for errors",
    errorLogging: "Log errors to monitoring service"
  },

  // Performance Rules
  performance: {
    memoization: "Use React.memo for expensive components",
    callbackMemo: "Use useCallback for event handlers",
    valueMemo: "Use useMemo for expensive calculations",
    codeSplitting: "Use React.lazy for route-level components"
  }
};

// Higher-Order Component with Integration Rules
export const withErrorBoundary = (WrappedComponent, fallbackComponent) => {
  return class ErrorBoundary extends React.Component {
    state = { hasError: false, error: null };

    static getDerivedStateFromError(error) {
      return { hasError: true, error };
    }

    componentDidCatch(error, errorInfo) {
      // Log error to monitoring service
      console.error('Component Error:', error, errorInfo);
      
      // Send to error tracking service
      if (window.analytics) {
        window.analytics.track('component_error', {
          error: error.message,
          component: WrappedComponent.name,
          stack: errorInfo.componentStack
        });
      }
    }

    render() {
      if (this.state.hasError) {
        if (fallbackComponent) {
          return React.createElement(fallbackComponent, {
            error: this.state.error,
            onRetry: () => this.setState({ hasError: false, error: null })
          });
        }
        
        return (
          <div className="tw-p-4 tw-bg-red-50 tw-border tw-border-red-200 tw-rounded-lg">
            <h3 className="tw-text-lg tw-font-medium tw-text-red-800">
              Something went wrong
            </h3>
            <p className="tw-text-red-600 tw-mt-2">
              {this.state.error?.message}
            </p>
            <button
              onClick={() => this.setState({ hasError: false, error: null })}
              className="tw-mt-3 tw-bg-red-100 hover:tw-bg-red-200 tw-text-red-700 tw-px-4 tw-py-2 tw-rounded"
            >
              Try Again
            </button>
          </div>
        );
      }

      return <WrappedComponent {...this.props} />;
    }
  };
};
ğŸ“Š ANALYTICS & MONITORING INTEGRATION
javascript
// analytics/analytics-integration-rules.js
export const AnalyticsIntegrationRules = {
  // Event Tracking
  events: {
    pageViews: {
      route: 'string',
      timestamp: 'ISO8601',
      userId: 'string',
      sessionId: 'string'
    },
    userActions: {
      action: 'string',
      element: 'string',
      context: 'object',
      timestamp: 'ISO8601'
    },
    errors: {
      error: 'string',
      stack: 'string',
      context: 'object',
      timestamp: 'ISO8601'
    }
  },

  // Performance Monitoring
  performance: {
    apiResponseTimes: 'track all API call durations',
    componentRenderTimes: 'track slow component renders',
    pageLoadTimes: 'track route navigation performance'
  }
};

// Analytics Hook with Integration Rules
export const useAnalytics = () => {
  const trackEvent = useCallback((eventName, properties = {}) => {
    // Don't track in development
    if (process.env.NODE_ENV === 'development') return;

    const event = {
      name: eventName,
      properties: {
        ...properties,
        timestamp: new Date().toISOString(),
        userId: getCurrentUserId(),
        sessionId: getSessionId(),
        userAgent: navigator.userAgent,
        url: window.location.href
      }
    };

    // Send to analytics service
    if (window.analytics) {
      window.analytics.track(eventName, event.properties);
    }

    // Also log to console in development
    console.log(`[Analytics] ${eventName}:`, event.properties);
  }, []);

  const trackPageView = useCallback((route, additionalProps = {}) => {
    trackEvent('page_view', {
      route,
      ...additionalProps
    });
  }, [trackEvent]);

  const trackUserAction = useCallback((action, element, context = {}) => {
    trackEvent('user_action', {
      action,
      element,
      context
    });
  }, [trackEvent]);

  return {
    trackEvent,
    trackPageView,
    trackUserAction
  };
};
ğŸ”§ DEPLOYMENT & ENVIRONMENT INTEGRATION
javascript
// config/environment-integration-rules.js
export const EnvironmentIntegrationRules = {
  // Environment Variables
  env: {
    required: [
      'REACT_APP_API_URL',
      'REACT_APP_WS_URL',
      'REACT_APP_ANALYTICS_ID'
    ],
    optional: [
      'REACT_APP_SENTRY_DSN',
      'REACT_APP_LOGGING_LEVEL'
    ]
  },

  // Feature Flags
  featureFlags: {
    release: {
      newMatchingAlgorithm: true,
      videoSessions: false,
      advancedAnalytics: true
    },
    development: {
      newMatchingAlgorithm: true,
      videoSessions: true,
      advancedAnalytics: true
    }
  },

  // API Endpoints
  endpoints: {
    development: {
      api: 'http://localhost:5000/api',
      ws: 'ws://localhost:5000'
    },
    staging: {
      api: 'https://staging-api.mentorplatform.com/api',
      ws: 'wss://staging-api.mentorplatform.com'
    },
    production: {
      api: 'https://api.mentorplatform.com/api',
      ws: 'wss://api.mentorplatform.com'
    }
  }
};

// Configuration Hook with Integration Rules
export const useConfig = () => {
  const validateEnvironment = () => {
    const missingVars = EnvironmentIntegrationRules.env.required.filter(
      varName => !process.env[varName]
    );

    if (missingVars.length > 0) {
      throw new Error(
        `Missing required environment variables: ${missingVars.join(', ')}`
      );
    }
  };

  const getApiUrl = () => {
    const env = process.env.NODE_ENV;
    return EnvironmentIntegrationRules.endpoints[env]?.api || 
           EnvironmentIntegrationRules.endpoints.production.api;
  };

  const getWebSocketUrl = () => {
    const env = process.env.NODE_ENV;
    return EnvironmentIntegrationRules.endpoints[env]?.ws || 
           EnvironmentIntegrationRules.endpoints.production.ws;
  };

  const isFeatureEnabled = (featureName) => {
    const env = process.env.NODE_ENV;
    return EnvironmentIntegrationRules.featureFlags[env]?.[featureName] ?? false;
  };

  return {
    validateEnvironment,
    getApiUrl,
    getWebSocketUrl,
    isFeatureEnabled
  };
};
ğŸ“ INTEGRATION CHECKLIST
javascript
// utils/integration-checklist.js
export const IntegrationChecklist = {
  beforePR: [
    "âœ… All API calls use React Query hooks",
    "âœ… Error boundaries wrap major components",
    "âœ… PropTypes/TypeScript definitions updated",
    "âœ… Tailwind classes use tw- prefix only",
    "âœ… No inline styles or custom CSS",
    "âœ… Loading states implemented for all async operations",
    "âœ… Error states handled gracefully",
    "âœ… Real-time updates tested",
    "âœ… Performance optimizations applied",
    "âœ… Accessibility attributes included"
  ],

  beforeDeploy: [
    "âœ… Environment variables validated",
    "âœ… Feature flags configured",
    "âœ… Analytics events tracked",
    "âœ… Error logging integrated",
    "âœ… API endpoints verified",
    "âœ… WebSocket connections stable",
    "âœ… Mobile responsiveness tested",
    "âœ… Cross-browser compatibility checked"
  ]
};
This comprehensive integration rule system ensures consistency, maintainability, and scalability across your MERN stack Mentoring Platform while strictly following the tw- prefix requirements for Tailwind CSS.