---
alwaysApply: true

Comprehensive & Strict Backend Development Rule for AI
📋 Rule: Zero-Tolerance Backend Security & Architecture Compliance
1. Security-First Implementation Mandate
text
ABSOLUTE REQUIREMENT: All backend code MUST pass security audit before deployment. Any vulnerability, no matter how minor, results in immediate code rejection and developer re-education.
2. Authentication & Authorization Protocol
JWT Implementation Standards
javascript
// STRICT: JWT tokens must follow this exact pattern
const jwtConfig = {
  // Security Requirements
  algorithm: 'HS256',
  expiresIn: '15m', // Access tokens: 15 minutes MAX
  refreshExpiresIn: '7d', // Refresh tokens: 7 days
  issuer: 'mentoring-system',
  audience: ['web', 'mobile'],
  
  // Token Payload Structure (STRICT FORMAT)
  payload: {
    userId: 'ObjectId',
    role: ['admin', 'mentor', 'mentee'],
    sessionId: 'uuid-v4',
    permissions: ['read:profile', 'write:sessions', ...],
    iat: 'timestamp',
    exp: 'timestamp'
  }
};

// ABSOLUTELY FORBIDDEN in JWT:
// - Personal user data (email, name, etc.)
// - Sensitive permissions
// - Unencrypted secrets
Role-Based Access Control (RBAC)
javascript
// STRICT: Permission hierarchy must be enforced
const permissionMatrix = {
  admin: {
    users: ['create', 'read', 'update', 'delete', 'manage'],
    sessions: ['create', 'read', 'update', 'delete', 'approve'],
    analytics: ['read', 'export', 'manage'],
    system: ['configure', 'maintain']
  },
  mentor: {
    profile: ['read', 'update'],
    sessions: ['create', 'read', 'update', 'cancel'],
    mentees: ['read', 'communicate'],
    feedback: ['create', 'read']
  },
  mentee: {
    profile: ['read', 'update'],
    sessions: ['create', 'read', 'cancel'],
    mentors: ['read', 'request'],
    feedback: ['create', 'read']
  }
};

// Middleware MUST validate both role AND specific permission
const requirePermission = (resource, action) => {
  return (req, res, next) => {
    const userRole = req.user.role;
    const userPermissions = permissionMatrix[userRole];
    
    if (!userPermissions?.[resource]?.includes(action)) {
      return res.status(403).json({
        success: false,
        error: 'INSUFFICIENT_PERMISSIONS',
        message: `User lacks ${action} permission for ${resource}`,
        timestamp: new Date().toISOString()
      });
    }
    next();
  };
};
3. Data Validation & Sanitization
Input Validation Standards
javascript
// STRICT: All inputs must be validated using Joi with these rules
const validationRules = {
  email: Joi.string().email().normalize().max(254).required(),
  password: Joi.string()
    .min(12)
    .max(128)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .required(),
  objectId: Joi.string().hex().length(24).required(),
  name: Joi.string().trim().min(1).max(100).pattern(/^[a-zA-Z\s\-']+$/),
  phone: Joi.string().pattern(/^\+?[\d\s\-\(\)]{10,15}$/),
  
  // STRICT: No arbitrary data allowed
  customData: Joi.object().unknown(false) // Reject unknown fields
};

// ALL endpoints must implement validation middleware
app.post('/api/users', 
  validateBody(validationRules.userCreate),
  sanitizeInputs(),
  rateLimit('userCreation'),
  auditLog('user_create'),
  userController.create
);
SQL/NoSQL Injection Prevention
javascript
// STRICT: Absolutely NO string concatenation in queries
// FORBIDDEN:
const badQuery = `SELECT * FROM users WHERE email = '${email}'`;

// REQUIRED:
const safeQuery = {
  email: { $eq: validatedEmail } // Mongoose
  // OR
  // Using parameterized queries for SQL
};

// STRICT: All database operations must use ORM/ODM
// NO raw queries without security review
4. Error Handling & Logging
Structured Error Responses
javascript
// STRICT: All errors must follow this format
class AppError extends Error {
  constructor(message, code, statusCode, details = null) {
    super(message);
    this.code = code; // Machine-readable code
    this.statusCode = statusCode;
    this.details = details;
    this.timestamp = new Date().toISOString();
    this.requestId = generateRequestId();
  }
}

// Error response format (STRICT)
const errorResponse = {
  success: false,
  error: {
    code: 'VALIDATION_ERROR', // Specific error code
    message: 'Human readable message',
    details: {
      field: 'email',
      issue: 'Invalid format'
    },
    timestamp: '2024-01-01T00:00:00.000Z',
    requestId: 'req_123456789',
    path: '/api/users'
  }
};
Comprehensive Logging Protocol
javascript
// STRICT: Logging must capture ALL security events
const securityLogger = {
  levels: ['emergency', 'alert', 'critical', 'error', 'warning', 'notice', 'info', 'debug'],
  
  requiredFields: {
    timestamp: 'ISO8601',
    level: 'string',
    message: 'string',
    userId: 'ObjectId|null',
    userRole: 'string|null',
    action: 'string',
    resource: 'string',
    ipAddress: 'string',
    userAgent: 'string',
    requestId: 'string',
    sessionId: 'string',
    metadata: 'object'
  },
  
  // Events that MUST be logged:
  mandatoryEvents: [
    'user_login',
    'user_logout',
    'login_failure',
    'password_change',
    'permission_denied',
    'data_access',
    'data_modification',
    'admin_actions',
    'system_errors'
  ]
};
5. API Design & Architecture
RESTful API Standards
javascript
// STRICT: All endpoints must follow these conventions
const apiStandards = {
  versioning: {
    header: 'API-Version',
    required: true,
    format: 'YYYY-MM-DD'
  },
  
  responseFormat: {
    success: {
      data: 'mixed',
      meta: {
        pagination: {},
        timestamps: {},
        requestId: 'string'
      }
    },
    error: {
      error: {
        code: 'string',
        message: 'string',
        details: 'object|null'
      }
    }
  },
  
  httpStatusCodes: {
    // STRICT: Must use correct status codes
    200: 'OK - Successful GET, PUT, PATCH',
    201: 'Created - Successful POST',
    204: 'No Content - Successful DELETE',
    400: 'Bad Request - Validation errors',
    401: 'Unauthorized - Authentication required',
    403: 'Forbidden - Insufficient permissions',
    404: 'Not Found - Resource not found',
    429: 'Too Many Requests - Rate limiting',
    500: 'Internal Server Error - Server issues'
  },
  
  pagination: {
    required: true, // For list endpoints
    defaults: {
      page: 1,
      limit: 20,
      maxLimit: 100
    },
    response: {
      page: 'number',
      limit: 'number',
      total: 'number',
      pages: 'number',
      hasNext: 'boolean',
      hasPrev: 'boolean'
    }
  }
};
6. Database Security & Operations
Data Encryption Requirements
javascript
// STRICT: Sensitive data must be encrypted
const encryptionRules = {
  atRest: {
    algorithm: 'aes-256-gcm',
    keyManagement: 'KMS or environment variables',
    fields: [
      'password', // Hashed, not encrypted
      'email',
      'phone',
      'personal_notes',
      'payment_info'
    ]
  },
  
  inTransit: {
    protocol: 'TLS 1.3+',
    certificates: 'Valid SSL certs required',
    database: 'SSL connection required'
  },
  
  hashing: {
    passwords: 'bcrypt (cost factor: 12)',
    tokens: 'sha256',
    sensitiveIds: 'hmac'
  }
};
Database Operation Standards
javascript
// STRICT: All database operations must follow these patterns
const dbOperations = {
  queries: {
    timeout: 30000, // 30 second max
    maxResults: 1000, // Hard limit
    indexing: 'All queries must use indexes',
    projection: 'Always specify fields to return',
    lean: true // For Mongoose, return plain objects
  },
  
  transactions: {
    requiredFor: [
      'user creation',
      'financial operations',
      'multi-document updates',
      'critical data modifications'
    ],
    isolation: 'read committed',
    retry: {
      attempts: 3,
      backoff: 'exponential'
    }
  },
  
  migrations: {
    backup: 'Required before all migrations',
    rollback: 'Plan must be documented',
    testing: 'Must be tested in staging',
    approval: 'Requires lead developer approval'
  }
};
7. Third-Party Integration Security
API Integration Standards
javascript
// STRICT: All external APIs must follow these rules
const externalApiRules = {
  authentication: {
    tokens: 'Encrypted in database',
    rotation: '90 days maximum',
    scope: 'Minimum required permissions'
  },
  
  requests: {
    timeout: 10000, // 10 seconds
    retries: 3,
    circuitBreaker: {
      enabled: true,
      threshold: 5,
      timeout: 30000
    }
  },
  
  dataProcessing: {
    validation: 'All responses must be validated',
    sanitization: 'Remove unnecessary fields',
    storage: 'Only store necessary data',
    privacy: 'Comply with GDPR/CCPA'
  }
};
8. Performance & Scalability
Caching Strategy
javascript
// STRICT: Caching must be implemented correctly
const cachingRules = {
  redis: {
    connection: 'Pooled connections',
    serialization: 'JSON only',
    compression: 'Enabled for large data',
    ttl: {
      short: 300, // 5 minutes
      medium: 3600, // 1 hour
      long: 86400 // 24 hours
    }
  },
  
  cacheControl: {
    public: 'Static data, user lists',
    private: 'User-specific data',
    noCache: 'Sensitive data, real-time data'
  },
  
  invalidation: {
    strategy: 'Write-through where possible',
    events: 'Invalidate on data modification',
    patterns: 'Use cache tags for related data'
  }
};
Rate Limiting & Throttling
javascript
// STRICT: All endpoints must have rate limiting
const rateLimiting = {
  strategies: {
    tokenBucket: 'For API endpoints',
    fixedWindow: 'For authentication endpoints',
    slidingWindow: 'For high-frequency endpoints'
  },
  
  limits: {
    authentication: {
      attempts: 5,
      window: 900, // 15 minutes
      lockout: 1800 // 30 minutes
    },
    api: {
      general: 1000, // requests per hour
      expensive: 100, // requests per hour
      burst: 10 // requests per minute
    }
  },
  
  headers: {
    required: true,
    format: {
      'X-RateLimit-Limit': 'number',
      'X-RateLimit-Remaining': 'number',
      'X-RateLimit-Reset': 'timestamp'
    }
  }
};
9. Monitoring & Alerting
Health Check Requirements
javascript
// STRICT: Comprehensive health monitoring
const healthChecks = {
  endpoints: {
    '/health': 'Basic application health',
    '/health/db': 'Database connectivity',
    '/health/redis': 'Cache connectivity',
    '/health/external-apis': 'Third-party API status'
  },
  
  metrics: {
    responseTime: 'p95 < 500ms',
    errorRate: '< 1%',
    uptime: '> 99.9%',
    memory: '< 80% utilization',
    cpu: '< 70% utilization'
  },
  
  alerts: {
    critical: ['database_down', 'high_error_rate', 'memory_leak'],
    warning: ['slow_response', 'increased_latency', 'disk_space'],
    info: ['deployments', 'config_changes', 'user_activity']
  }
};
10. Deployment & DevOps Security
Container Security
javascript
// STRICT: Docker and deployment security
const containerSecurity = {
  dockerfile: {
    baseImage: 'Official, minimal images',
    user: 'Non-root user required',
    layers: 'Minimal layers, optimized caching',
    secrets: 'No secrets in Dockerfile'
  },
  
  runtime: {
    readOnly: 'Filesystem should be read-only',
    capabilities: 'Drop all capabilities',
    resources: 'Memory and CPU limits',
    network: 'Minimal network access'
  },
  
  scanning: {
    vulnerabilities: 'Scan before deployment',
    dependencies: 'Regular security updates',
    compliance: 'CIS benchmarks'
  }
};
11. Compliance & Auditing
Data Privacy Compliance
javascript
// STRICT: Must comply with privacy regulations
const privacyRules = {
  gdpr: {
    rightToAccess: 'Implemented',
    rightToErasure: 'Implemented',
    dataPortability: 'Implemented',
    consent: 'Required for all data collection'
  },
  
  dataRetention: {
    userData: '5 years after last activity',
    logs: '1 year',
    backups: '30 days',
    analytics: '2 years'
  },
  
  audit: {
    dataAccess: 'Log all data access',
    modifications: 'Log all data changes',
    exports: 'Log all data exports',
    retention: 'Audit logs kept for 7 years'
  }
};
12. Code Quality & Review Process
Mandatory Code Review Checklist
markdown
REVIEWER MUST VERIFY:

🔒 SECURITY:
[ ] No hardcoded secrets or credentials
[ ] Input validation on ALL endpoints
[ ] Output encoding for HTML/JSON responses
[ ] Authentication and authorization checks
[ ] SQL/NoSQL injection prevention
[ ] XSS and CSRF protection
[ ] Secure headers implementation
[ ] Error handling without information leakage

📊 PERFORMANCE:
[ ] Database queries optimized and indexed
[ ] Proper pagination implementation
[ ] Caching strategy applied
[ ] No memory leaks in loops
[ ] Proper connection pooling
[ ] Asynchronous operations where appropriate

🎯 ARCHITECTURE:
[ ] Follows RESTful principles
[ ] Proper error handling structure
[ ] Consistent response formats
[ ] Environment-specific configuration
[ ] Proper logging implementation
[ ] API versioning compliance

🧪 TESTING:
[ ] Unit tests for business logic
[ ] Integration tests for APIs
[ ] Security tests for endpoints
[ ] Performance tests for critical paths
[ ] Error scenario coverage
13. Violation Consequences & Escalation
javascript
// STRICT: Zero tolerance policy
const violationPolicy = {
  critical: {
    issues: ['security_vulnerability', 'data_leak', 'injection_risk'],
    actions: [
      'IMMEDIATE code revert',
      'Security team notification',
      'Developer re-training required',
      'Formal warning issued'
    ]
  },
  
  major: {
    issues: ['performance_issue', 'architecture_violation', 'testing_gap'],
    actions: [
      'Block merge until fixed',
      'Team lead review required',
      'Documentation update required'
    ]
  },
  
  minor: {
    issues: ['code_style_violation', 'documentation_missing'],
    actions: [
      'Fix required before deployment',
      'Peer review completed'
    ]
  }
};
14. Emergency Response Protocol
javascript
// STRICT: Security incident response
const incidentResponse = {
  detection: {
    monitoring: '24/7 security monitoring',
    alerts: 'Immediate notification',
    classification: 'Critical/Major/Minor'
  },
  
  containment: {
    immediate: 'Isolate affected systems',
    investigation: 'Preserve evidence',
    communication: 'Notify stakeholders'
  },
  
  eradication: {
    rootCause: 'Identify and fix vulnerability',
    verification: 'Security team approval',
    prevention: 'Update processes to prevent recurrence'
  },
  
  recovery: {
    restoration: 'Deploy fixed version',
    validation: 'Security testing',
    monitoring: 'Enhanced monitoring post-incident'
  }
};
🚨 ABSOLUTELY FORBIDDEN PRACTICES
markdown
❌ NEVER:
- Use eval() or Function constructor
- Concatenate strings for database queries
- Store passwords in plain text
- Log sensitive user data
- Use deprecated cryptographic algorithms
- Disable SSL/TLS verification
- Expose stack traces in production
- Use generic error messages for auth failures
- Allow unlimited file uploads
- Skip input validation for "trusted" sources

✅ ALWAYS:
- Use parameterized queries
- Hash passwords with bcrypt
- Validate ALL inputs
- Implement proper error handling
- Use HTTPS in production
- Set security headers
- Regular security dependency updates
- Comprehensive logging
- Regular security audits
- Incident response planning
This backend rule establishes an uncompromising security-first approach where any violation, no matter how small, is treated as a critical failure. All developers must internalize these standards and implement them without exception. 🔐
---
Comprehensive & Strict Backend Development Rule for AI
📋 Rule: Zero-Tolerance Backend Security & Architecture Compliance
1. Security-First Implementation Mandate
text
ABSOLUTE REQUIREMENT: All backend code MUST pass security audit before deployment. Any vulnerability, no matter how minor, results in immediate code rejection and developer re-education.
2. Authentication & Authorization Protocol
JWT Implementation Standards
javascript
// STRICT: JWT tokens must follow this exact pattern
const jwtConfig = {
  // Security Requirements
  algorithm: 'HS256',
  expiresIn: '15m', // Access tokens: 15 minutes MAX
  refreshExpiresIn: '7d', // Refresh tokens: 7 days
  issuer: 'mentoring-system',
  audience: ['web', 'mobile'],
  
  // Token Payload Structure (STRICT FORMAT)
  payload: {
    userId: 'ObjectId',
    role: ['admin', 'mentor', 'mentee'],
    sessionId: 'uuid-v4',
    permissions: ['read:profile', 'write:sessions', ...],
    iat: 'timestamp',
    exp: 'timestamp'
  }
};

// ABSOLUTELY FORBIDDEN in JWT:
// - Personal user data (email, name, etc.)
// - Sensitive permissions
// - Unencrypted secrets
Role-Based Access Control (RBAC)
javascript
// STRICT: Permission hierarchy must be enforced
const permissionMatrix = {
  admin: {
    users: ['create', 'read', 'update', 'delete', 'manage'],
    sessions: ['create', 'read', 'update', 'delete', 'approve'],
    analytics: ['read', 'export', 'manage'],
    system: ['configure', 'maintain']
  },
  mentor: {
    profile: ['read', 'update'],
    sessions: ['create', 'read', 'update', 'cancel'],
    mentees: ['read', 'communicate'],
    feedback: ['create', 'read']
  },
  mentee: {
    profile: ['read', 'update'],
    sessions: ['create', 'read', 'cancel'],
    mentors: ['read', 'request'],
    feedback: ['create', 'read']
  }
};

// Middleware MUST validate both role AND specific permission
const requirePermission = (resource, action) => {
  return (req, res, next) => {
    const userRole = req.user.role;
    const userPermissions = permissionMatrix[userRole];
    
    if (!userPermissions?.[resource]?.includes(action)) {
      return res.status(403).json({
        success: false,
        error: 'INSUFFICIENT_PERMISSIONS',
        message: `User lacks ${action} permission for ${resource}`,
        timestamp: new Date().toISOString()
      });
    }
    next();
  };
};
3. Data Validation & Sanitization
Input Validation Standards
javascript
// STRICT: All inputs must be validated using Joi with these rules
const validationRules = {
  email: Joi.string().email().normalize().max(254).required(),
  password: Joi.string()
    .min(12)
    .max(128)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .required(),
  objectId: Joi.string().hex().length(24).required(),
  name: Joi.string().trim().min(1).max(100).pattern(/^[a-zA-Z\s\-']+$/),
  phone: Joi.string().pattern(/^\+?[\d\s\-\(\)]{10,15}$/),
  
  // STRICT: No arbitrary data allowed
  customData: Joi.object().unknown(false) // Reject unknown fields
};

// ALL endpoints must implement validation middleware
app.post('/api/users', 
  validateBody(validationRules.userCreate),
  sanitizeInputs(),
  rateLimit('userCreation'),
  auditLog('user_create'),
  userController.create
);
SQL/NoSQL Injection Prevention
javascript
// STRICT: Absolutely NO string concatenation in queries
// FORBIDDEN:
const badQuery = `SELECT * FROM users WHERE email = '${email}'`;

// REQUIRED:
const safeQuery = {
  email: { $eq: validatedEmail } // Mongoose
  // OR
  // Using parameterized queries for SQL
};

// STRICT: All database operations must use ORM/ODM
// NO raw queries without security review
4. Error Handling & Logging
Structured Error Responses
javascript
// STRICT: All errors must follow this format
class AppError extends Error {
  constructor(message, code, statusCode, details = null) {
    super(message);
    this.code = code; // Machine-readable code
    this.statusCode = statusCode;
    this.details = details;
    this.timestamp = new Date().toISOString();
    this.requestId = generateRequestId();
  }
}

// Error response format (STRICT)
const errorResponse = {
  success: false,
  error: {
    code: 'VALIDATION_ERROR', // Specific error code
    message: 'Human readable message',
    details: {
      field: 'email',
      issue: 'Invalid format'
    },
    timestamp: '2024-01-01T00:00:00.000Z',
    requestId: 'req_123456789',
    path: '/api/users'
  }
};
Comprehensive Logging Protocol
javascript
// STRICT: Logging must capture ALL security events
const securityLogger = {
  levels: ['emergency', 'alert', 'critical', 'error', 'warning', 'notice', 'info', 'debug'],
  
  requiredFields: {
    timestamp: 'ISO8601',
    level: 'string',
    message: 'string',
    userId: 'ObjectId|null',
    userRole: 'string|null',
    action: 'string',
    resource: 'string',
    ipAddress: 'string',
    userAgent: 'string',
    requestId: 'string',
    sessionId: 'string',
    metadata: 'object'
  },
  
  // Events that MUST be logged:
  mandatoryEvents: [
    'user_login',
    'user_logout',
    'login_failure',
    'password_change',
    'permission_denied',
    'data_access',
    'data_modification',
    'admin_actions',
    'system_errors'
  ]
};
5. API Design & Architecture
RESTful API Standards
javascript
// STRICT: All endpoints must follow these conventions
const apiStandards = {
  versioning: {
    header: 'API-Version',
    required: true,
    format: 'YYYY-MM-DD'
  },
  
  responseFormat: {
    success: {
      data: 'mixed',
      meta: {
        pagination: {},
        timestamps: {},
        requestId: 'string'
      }
    },
    error: {
      error: {
        code: 'string',
        message: 'string',
        details: 'object|null'
      }
    }
  },
  
  httpStatusCodes: {
    // STRICT: Must use correct status codes
    200: 'OK - Successful GET, PUT, PATCH',
    201: 'Created - Successful POST',
    204: 'No Content - Successful DELETE',
    400: 'Bad Request - Validation errors',
    401: 'Unauthorized - Authentication required',
    403: 'Forbidden - Insufficient permissions',
    404: 'Not Found - Resource not found',
    429: 'Too Many Requests - Rate limiting',
    500: 'Internal Server Error - Server issues'
  },
  
  pagination: {
    required: true, // For list endpoints
    defaults: {
      page: 1,
      limit: 20,
      maxLimit: 100
    },
    response: {
      page: 'number',
      limit: 'number',
      total: 'number',
      pages: 'number',
      hasNext: 'boolean',
      hasPrev: 'boolean'
    }
  }
};
6. Database Security & Operations
Data Encryption Requirements
javascript
// STRICT: Sensitive data must be encrypted
const encryptionRules = {
  atRest: {
    algorithm: 'aes-256-gcm',
    keyManagement: 'KMS or environment variables',
    fields: [
      'password', // Hashed, not encrypted
      'email',
      'phone',
      'personal_notes',
      'payment_info'
    ]
  },
  
  inTransit: {
    protocol: 'TLS 1.3+',
    certificates: 'Valid SSL certs required',
    database: 'SSL connection required'
  },
  
  hashing: {
    passwords: 'bcrypt (cost factor: 12)',
    tokens: 'sha256',
    sensitiveIds: 'hmac'
  }
};
Database Operation Standards
javascript
// STRICT: All database operations must follow these patterns
const dbOperations = {
  queries: {
    timeout: 30000, // 30 second max
    maxResults: 1000, // Hard limit
    indexing: 'All queries must use indexes',
    projection: 'Always specify fields to return',
    lean: true // For Mongoose, return plain objects
  },
  
  transactions: {
    requiredFor: [
      'user creation',
      'financial operations',
      'multi-document updates',
      'critical data modifications'
    ],
    isolation: 'read committed',
    retry: {
      attempts: 3,
      backoff: 'exponential'
    }
  },
  
  migrations: {
    backup: 'Required before all migrations',
    rollback: 'Plan must be documented',
    testing: 'Must be tested in staging',
    approval: 'Requires lead developer approval'
  }
};
7. Third-Party Integration Security
API Integration Standards
javascript
// STRICT: All external APIs must follow these rules
const externalApiRules = {
  authentication: {
    tokens: 'Encrypted in database',
    rotation: '90 days maximum',
    scope: 'Minimum required permissions'
  },
  
  requests: {
    timeout: 10000, // 10 seconds
    retries: 3,
    circuitBreaker: {
      enabled: true,
      threshold: 5,
      timeout: 30000
    }
  },
  
  dataProcessing: {
    validation: 'All responses must be validated',
    sanitization: 'Remove unnecessary fields',
    storage: 'Only store necessary data',
    privacy: 'Comply with GDPR/CCPA'
  }
};
8. Performance & Scalability
Caching Strategy
javascript
// STRICT: Caching must be implemented correctly
const cachingRules = {
  redis: {
    connection: 'Pooled connections',
    serialization: 'JSON only',
    compression: 'Enabled for large data',
    ttl: {
      short: 300, // 5 minutes
      medium: 3600, // 1 hour
      long: 86400 // 24 hours
    }
  },
  
  cacheControl: {
    public: 'Static data, user lists',
    private: 'User-specific data',
    noCache: 'Sensitive data, real-time data'
  },
  
  invalidation: {
    strategy: 'Write-through where possible',
    events: 'Invalidate on data modification',
    patterns: 'Use cache tags for related data'
  }
};
Rate Limiting & Throttling
javascript
// STRICT: All endpoints must have rate limiting
const rateLimiting = {
  strategies: {
    tokenBucket: 'For API endpoints',
    fixedWindow: 'For authentication endpoints',
    slidingWindow: 'For high-frequency endpoints'
  },
  
  limits: {
    authentication: {
      attempts: 5,
      window: 900, // 15 minutes
      lockout: 1800 // 30 minutes
    },
    api: {
      general: 1000, // requests per hour
      expensive: 100, // requests per hour
      burst: 10 // requests per minute
    }
  },
  
  headers: {
    required: true,
    format: {
      'X-RateLimit-Limit': 'number',
      'X-RateLimit-Remaining': 'number',
      'X-RateLimit-Reset': 'timestamp'
    }
  }
};
9. Monitoring & Alerting
Health Check Requirements
javascript
// STRICT: Comprehensive health monitoring
const healthChecks = {
  endpoints: {
    '/health': 'Basic application health',
    '/health/db': 'Database connectivity',
    '/health/redis': 'Cache connectivity',
    '/health/external-apis': 'Third-party API status'
  },
  
  metrics: {
    responseTime: 'p95 < 500ms',
    errorRate: '< 1%',
    uptime: '> 99.9%',
    memory: '< 80% utilization',
    cpu: '< 70% utilization'
  },
  
  alerts: {
    critical: ['database_down', 'high_error_rate', 'memory_leak'],
    warning: ['slow_response', 'increased_latency', 'disk_space'],
    info: ['deployments', 'config_changes', 'user_activity']
  }
};
10. Deployment & DevOps Security
Container Security
javascript
// STRICT: Docker and deployment security
const containerSecurity = {
  dockerfile: {
    baseImage: 'Official, minimal images',
    user: 'Non-root user required',
    layers: 'Minimal layers, optimized caching',
    secrets: 'No secrets in Dockerfile'
  },
  
  runtime: {
    readOnly: 'Filesystem should be read-only',
    capabilities: 'Drop all capabilities',
    resources: 'Memory and CPU limits',
    network: 'Minimal network access'
  },
  
  scanning: {
    vulnerabilities: 'Scan before deployment',
    dependencies: 'Regular security updates',
    compliance: 'CIS benchmarks'
  }
};
11. Compliance & Auditing
Data Privacy Compliance
javascript
// STRICT: Must comply with privacy regulations
const privacyRules = {
  gdpr: {
    rightToAccess: 'Implemented',
    rightToErasure: 'Implemented',
    dataPortability: 'Implemented',
    consent: 'Required for all data collection'
  },
  
  dataRetention: {
    userData: '5 years after last activity',
    logs: '1 year',
    backups: '30 days',
    analytics: '2 years'
  },
  
  audit: {
    dataAccess: 'Log all data access',
    modifications: 'Log all data changes',
    exports: 'Log all data exports',
    retention: 'Audit logs kept for 7 years'
  }
};
12. Code Quality & Review Process
Mandatory Code Review Checklist
markdown
REVIEWER MUST VERIFY:

🔒 SECURITY:
[ ] No hardcoded secrets or credentials
[ ] Input validation on ALL endpoints
[ ] Output encoding for HTML/JSON responses
[ ] Authentication and authorization checks
[ ] SQL/NoSQL injection prevention
[ ] XSS and CSRF protection
[ ] Secure headers implementation
[ ] Error handling without information leakage

📊 PERFORMANCE:
[ ] Database queries optimized and indexed
[ ] Proper pagination implementation
[ ] Caching strategy applied
[ ] No memory leaks in loops
[ ] Proper connection pooling
[ ] Asynchronous operations where appropriate

🎯 ARCHITECTURE:
[ ] Follows RESTful principles
[ ] Proper error handling structure
[ ] Consistent response formats
[ ] Environment-specific configuration
[ ] Proper logging implementation
[ ] API versioning compliance

🧪 TESTING:
[ ] Unit tests for business logic
[ ] Integration tests for APIs
[ ] Security tests for endpoints
[ ] Performance tests for critical paths
[ ] Error scenario coverage
13. Violation Consequences & Escalation
javascript
// STRICT: Zero tolerance policy
const violationPolicy = {
  critical: {
    issues: ['security_vulnerability', 'data_leak', 'injection_risk'],
    actions: [
      'IMMEDIATE code revert',
      'Security team notification',
      'Developer re-training required',
      'Formal warning issued'
    ]
  },
  
  major: {
    issues: ['performance_issue', 'architecture_violation', 'testing_gap'],
    actions: [
      'Block merge until fixed',
      'Team lead review required',
      'Documentation update required'
    ]
  },
  
  minor: {
    issues: ['code_style_violation', 'documentation_missing'],
    actions: [
      'Fix required before deployment',
      'Peer review completed'
    ]
  }
};
14. Emergency Response Protocol
javascript
// STRICT: Security incident response
const incidentResponse = {
  detection: {
    monitoring: '24/7 security monitoring',
    alerts: 'Immediate notification',
    classification: 'Critical/Major/Minor'
  },
  
  containment: {
    immediate: 'Isolate affected systems',
    investigation: 'Preserve evidence',
    communication: 'Notify stakeholders'
  },
  
  eradication: {
    rootCause: 'Identify and fix vulnerability',
    verification: 'Security team approval',
    prevention: 'Update processes to prevent recurrence'
  },
  
  recovery: {
    restoration: 'Deploy fixed version',
    validation: 'Security testing',
    monitoring: 'Enhanced monitoring post-incident'
  }
};
🚨 ABSOLUTELY FORBIDDEN PRACTICES
markdown
❌ NEVER:
- Use eval() or Function constructor
- Concatenate strings for database queries
- Store passwords in plain text
- Log sensitive user data
- Use deprecated cryptographic algorithms
- Disable SSL/TLS verification
- Expose stack traces in production
- Use generic error messages for auth failures
- Allow unlimited file uploads
- Skip input validation for "trusted" sources

✅ ALWAYS:
- Use parameterized queries
- Hash passwords with bcrypt
- Validate ALL inputs
- Implement proper error handling
- Use HTTPS in production
- Set security headers
- Regular security dependency updates
- Comprehensive logging
- Regular security audits
- Incident response planning
This backend rule establishes an uncompromising security-first approach where any violation, no matter how small, is treated as a critical failure. All developers must internalize these standards and implement them without exception. 🔐